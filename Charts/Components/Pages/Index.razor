@page "/"
@using Charts.Models
@using Syncfusion.Blazor.Charts
@inject ApiService ApiService
@inject IJSRuntime Js
@rendermode InteractiveServer

@* Todo
- check long/lat data
- when no data found
- another data point instead of temp
- link to long/lat picker
- footer w/ copyright
- restructrue methods
- month length (axis label) check
- move fetching classes to new WeatherService

*@

<PageTitle>Blazor Weather App</PageTitle>

<script>
    window.registerViewportChangeCallback = (dotnetHelper) => {
        window.addEventListener('load', () => {
            dotnetHelper.invokeMethodAsync('OnResize', window.innerWidth, window.innerHeight);
        });
        window.addEventListener('resize', () => {
            dotnetHelper.invokeMethodAsync('OnResize', window.innerWidth, window.innerHeight);
        });
    }
</script>

<div class="container">
    <div class="input-section">
        Lat: <input type="text" @bind="Latitude" placeholder="Latitude" pattern="-?\d+(\.\d*)?" oninput="this.value = this.value.replace(/[^0-9\.]/g, '');">
        Long: <input type="text" @bind="Longitude" placeholder="Longitude" pattern="-?\d+(\.\d*)?" oninput="this.value = this.value.replace(/[^0-9\.]/g, '');">
        @if (displayIcon)
        {
            <button @onclick="RefreshData" type="button" class="btn btn-primary" style="font-family: Segoe MDL2 Assets;">&#xE895;</button>
        }
        else
        {
            <button @onclick="RefreshData" type="button" class="btn btn-primary">Refresh</button>
        }
        @if (IsDataAvailable == false)
        {
            <br />
            <span style="color: red">Please choose coordinates inside Germany.</span>
        }
    </div>

    <div class="weather-container">
        <h3>Current Weather</h3>
        <h4>Station: @StationName</h4>
        @if (CurrentWeather == null)
        {
            <p>Loading....</p>
        }
        else
        {
            <div class="current-temp">
                @switch (Icon)
                {
                    case "sunny":
                        @:<img src="/images/sunny.png" alt="Sunny" id="weatherImage">
                        break;

                    case "cloudy":
                        @:<img src="/images/cloudy.png" alt="Cloudy" id="weatherImage">
                        break;

                    case "partly-cloudy":
                        @:<img src="/images/partly-cloudy.png" alt="Partly Cloudy" id="weatherImage">
                        break;

                    case "rainy":
                        @:<img src="/images/rainy.png" alt="Rainy" id="weatherImage">
                        break;

                    case "thunderstorm":
                        @:<img src="/images/thunderstorm.png" alt="Thunderstorm" id="weatherImage">
                        break;

                    case "clear-night":
                        @:<img src="/images/clear-night.png" alt="Clear Night" id="weatherImage">
                        break;

                    case "cloudy-night":
                        @:<img src="/images/cloudy-night.png" alt="Cloudy Night" id="weatherImage">
                        break;

                }
                <span class="value" id="temperature">@Temperature °C</span>
            </div>

            <div class="data-group">
                <div class="data-item">
                    <i class="fas fa-thermometer-half"></i>
                    <span class="label">Temperature:</span>
                    <span class="value" id="temperature">@Temperature°C</span>
                </div>
                <div class="data-item">
                    <i class="fas fa-tint"></i>
                    <span class="label">Dew Point:</span>
                    <span class="value" id="dewpoint">@(DewPoint)°C</span>
                </div>
            </div>

            <div class="data-group">
                <div class="data-item">
                    <i class="fas fa-water"></i>
                    <span class="label">Humidity:</span>
                    <span class="value" id="humidity">@_humidity %</span>
                </div>
                <div class="data-item">
                    <i class="fas fa-cloud"></i>
                    <span class="label">Cloud Cover:</span>
                    <span class="value" id="cloudCover">@CloudCover %</span>
                </div>
            </div>
        }
    </div>

    <div class="historical-averages">
        <h3>Historical Data for @System.DateTime.Now.ToString("dd MMM")</h3>
        <ul>
            <li>Mean Daily Maximum: @MaxTemp.ToString("F1") °C</li>
            <li>Daily Mean: @MeanTemp.ToString("F1") °C</li>
            <li>Mean Daily Minimum: @MinTemp.ToString("F1") °C</li>
            <li>Precipitation: @Precipitation.ToString("F1") mm</li>
            <li>Sunshine Hours: @SunshineHours.ToString("F1") hours</li>
            <li>Record High: @RecordHigh.ToString("F1") °C (@RecordHighYear)</li>
            <li>Record Low: @RecordLow.ToString("F1") °C (@RecordLowYear)</li>
        </ul>
    </div>

    <div class="linechart">
        <h3>Mean Temperatures and Precipitation for @DateTime.Now.ToString("MMMM")</h3>
        <SfChart Width="@Width" >
            <ChartPrimaryXAxis Title="Day" ValueType="Syncfusion.Blazor.Charts.ValueType.Category" LabelIntersectAction="LabelIntersectAction.Hide">
                <ChartAxisMajorGridLines Width="0" Color="blue" />
            </ChartPrimaryXAxis>
            <ChartPrimaryYAxis Title="Temperatures"></ChartPrimaryYAxis>
            <ChartAxes>
                <ChartAxis Name="YAxis" OpposedPosition="true" Title="Precipitation in mm"/>
            </ChartAxes>

            <ChartTooltipSettings Enable="true" Shared="true">
                <Template>
                    @{
                        var data = context as List<ChartTooltipInfo>;
                        <div>
                            <table style="width:100%;  border: 0px solid black; background-color: rgba(255, 255, 255, 0.7); padding: 10px;" class="table-borderless">
                                <tr>
                                    <th colspan="2">@data[0].X</th>
                                </tr>
                                <tr style="">
                                    <td style="text-align: left;">Max Temperature in °C</td>
                                    <td style="text-align: right;">@data[0].High</td>
                                </tr>
                                <tr>
                                    <td style="text-align: left;">Min Temperature in °C</td>
                                    <td style="text-align: right;">@data[0].Low</td>
                                </tr>
                                <tr>
                                    <td style="text-align: left;">Precipitation in mm</td>
                                    <td style="text-align: right;">@data[1].Y</td>
                                </tr>
                            </table>
                        </div>
                    }
                </Template>
            </ChartTooltipSettings>
            
            <ChartSeriesCollection>
                <ChartSeries DataSource="@Temperatures" XName="X" High="High" Low="Low" Type="ChartSeriesType.RangeArea" Width="2" Fill="red" Opacity="0.1">
                    <ChartMarker Visible="true" Height="5" Width="5" Shape="ChartShape.Circle" IsFilled="true" />
                </ChartSeries>
                <ChartSeries DataSource="@Temperatures" XName="X" YName="Precipitation" Type="ChartSeriesType.Column" YAxisName="YAxis" Fill="#FEC007" ColumnWidth="1.5">
                </ChartSeries>
                @* <ChartSeries DataSource="@MinimumTemperatures" XName="X" YName="Y" Type="ChartSeriesType.Area" Width="2" Fill="blue" Opacity="0.1">
                    <ChartMarker Visible="true" Height="5" Width="5" Shape="ChartShape.Circle" IsFilled="true" />
                </ChartSeries> *@
            </ChartSeriesCollection>

            <ChartLegendSettings Visible="true" Position="LegendPosition.Top" />
        </SfChart>
    </div>

    <div class="get-source-code">
        <a href="https://github.com/extrasharp/BlazorWeatherApp" type="button" class="btn btn-primary">Source Code</a>
    </div>
</div>


@code {

    public class ChartData
    {
        public string X { get; set; }
        public double Y { get; set; }
    }
    public class ChartData2
    {
        public string X { get; set; }
        public double High { get; set; }
        public double Low { get; set; }
        public double Precipitation { get; set; }
    }
    #region Private Members
    private string Width { get; set; } = "730";
    private List<ChartData> MaximumTemperatures = [];
    private List<ChartData> MinimumTemperatures = [];
    private List<ChartData2> Temperatures = [];
    private int ViewportWidth { get; set; }
    private int ViewportHeight { get; set; }
    private WeatherResponseModel? CurrentWeather { get; set; }
    private string? StationName { get; set; }
    private bool IsDataAvailable { get; set; } = true;
    private double RecordHigh { get; set; }
    private double MaxTemp { get; set; }
    private int RecordLowYear { get; set; }
    private int RecordHighYear { get; set; }
    private double MeanTemp { get; set; }
    private double MinTemp { get; set; }
    private double Precipitation { get; set; }
    private double SunshineHours { get; set; }
    private double RecordLow { get; set; }
    private double? CloudCover { get; set; }
    private string Latitude { get; set; }
    private string Longitude { get; set; }
    private string Icon { get; set; }
    private static Boolean bigWindowSize = true;

    private double? _temperature;
    private double? Temperature
    {
        get => _temperature;
        set => _temperature = value.HasValue ? Math.Round(value.Value, 1) : null;
    }
    private double? _humidity;
     
    bool displayIcon = false; 
    

    private double? _dewPoint;
    private double? DewPoint
    {
        get => _dewPoint;
        set => _dewPoint = value.HasValue ? Math.Round(value.Value, 1) : null;
    }
    #endregion

    #region Methods
    [JSInvokable]
    public void OnResize(int width, int height)
    {
        if (ViewportWidth == width && ViewportHeight == height) return;
    
        ViewportWidth = width;
        ViewportHeight = height;

        switch (ViewportWidth)
        {
            case < 410:
                Width = "250";
                displayIcon = true;
                break;
            case < 468:
                Width = "300";
                displayIcon = true;
                break;
            case < 769:
                Width = "600";
                displayIcon = true;
                break;
            case < 1000:
                Width = "730";
                displayIcon = true;
                break;
            default:
                Width = "730";
                displayIcon = false;
                break;
        }
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Js.InvokeVoidAsync("window.registerViewportChangeCallback", DotNetObjectReference.Create(this));
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Latitude = "51.04";
        Longitude = "13.74";

        await RefreshData();
    }

    private async Task GetDisplayData()
    {
        var desiredDate = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day);
        var responses = await FetchHistoricalWeatherData(desiredDate);
        var mergedResponse = MergeWeatherResponses(responses, DateTime.Now.Day);
        var days = CalculateDailyMeans(mergedResponse);

        DisplayDailyMeans(days);
    }

    private async Task GetChartData()
    {
        var entireMonth = await FetchEntireMonth();
        var dayModels = CreateDayModels(entireMonth);
        var groupedDayModels = GroupDayModels(dayModels);

        PopulateChartData(groupedDayModels);
    }

    private async Task<List<WeatherModel>> FetchEntireMonth()
    {
        var today = DateTime.Today;
        var desiredDate = new DateTime(today.Year, today.Month, today.Day);

        var responses = await FetchHistoricalWeatherData(desiredDate, true);

        return responses
            .Where(r => r != null)
            .SelectMany(r => r.weather ?? Enumerable.Empty<WeatherModel>())
            .Where(weather => weather.TimeStamp.Month == today.Month) // Filter by month
            .ToList();
    }

    private static List<DayModel> CreateDayModels(IEnumerable<WeatherModel> mergedList)
    {
        return mergedList
            .Where(weather => weather.Temperature.HasValue)
            .GroupBy(weather => new { Day = weather.TimeStamp.Day, Month = weather.TimeStamp.Month, Year = weather.TimeStamp.Year })
            .Select(group => new DayModel
                {
                    Day = group.First().TimeStamp.Day,
                    Month = group.First().TimeStamp.Month,
                    Year = group.First().TimeStamp.Year,
                    MaxTemp = (double)group.Max(weather => weather.Temperature),
                    MinTemp = (double)group.Min(weather => weather.Temperature),
                    Precipitation = group.Average(weather => weather.Precipitation ?? double.MinValue)
                    // Include other properties as needed
                })
            .ToList();
    }

    private static List<DayModel> GroupDayModels(IEnumerable<DayModel> dayModels)
    {
        return dayModels
            .GroupBy(dayModel => dayModel.Day)
            .Select(group => new DayModel
                {
                    Day = group.Key,
                    MaxTemp = group.Average(dayModel => dayModel.MaxTemp),
                    MinTemp = group.Average(dayModel => dayModel.MinTemp),
                    Precipitation = group.Sum(dayModel => dayModel.Precipitation)
                    // Include other properties as needed
                })
            .ToList();
    }

    private void PopulateChartData(List<DayModel> groupedDayModels)
    {
        MaximumTemperatures.Clear();
        MinimumTemperatures.Clear();
        Temperatures.Clear();

        foreach (var day in groupedDayModels)
        {
            Temperatures.Add(new ChartData2 { X = day.Day.ToString(), High = day.MaxTemp, Low = day.MinTemp, Precipitation = day.Precipitation}); 
            MaximumTemperatures.Add(new ChartData { X = day.Day.ToString(), Y = day.MaxTemp });
            MinimumTemperatures.Add(new ChartData { X = day.Day.ToString(), Y = day.MinTemp });
        }
    }

    private async Task RefreshData()
    {
        CurrentWeather = null;
        
        // Validate latitude and longitude inputs
        if (string.IsNullOrWhiteSpace(Latitude) || string.IsNullOrWhiteSpace(Longitude))
        {
            // Handle validation error
            return;
        }

        if (IsValidCoordinates())
        {
            CurrentWeather = await ApiService.GetCurrentWeatherData(Latitude, Longitude);
        }

        if (CurrentWeather is { weather: not null })
        {
            AssignValues();
            await GetDisplayData();
            await GetChartData();
            IsDataAvailable = true;
        }
        else
        {
            IsDataAvailable = false;
        }
    }

    private bool IsValidCoordinates()
    {
        var latitude = double.Parse(Latitude);
        var longitude = double.Parse(Longitude);
        
        return latitude is <= 90 and >= -90 && longitude is <= 180 and >= -180;
    }

    private static List<DayModel> CalculateDailyMeans(MultipleWeatherResponseModel mergedResponse)
    {
        var groupedByDay = mergedResponse.weather
            .GroupBy(w => w.TimeStamp.Date);

        return groupedByDay.Select(group => new DayModel
            {
                Day = group.Key.Day,
                Month = group.Key.Month,
                Year = group.Key.Year,
                MeanTemp = group.Average(w => w?.Temperature ?? 0), // Calculate the mean temperature
                MaxTemp = group.Max(w => w?.Temperature ?? 0), // Calculate the mean temperature
                MinTemp = group.Min(w => w?.Temperature ?? 0),
                Precipitation = group.Sum(w => w?.Precipitation ?? 0),
                SunshineHours = group.Sum(w => w?.SunshineHours / 60 ?? 0) // Calculate the mean temperature
            })
            .ToList();
    }

    private async Task<MultipleWeatherResponseModel?[]> FetchHistoricalWeatherData(DateTime desiredDate, bool monthly = false)
    {
        var tasks = new List<Task<MultipleWeatherResponseModel?>>();

        if (monthly)
        {
            var firstDayOfMonth = new DateTime(desiredDate.Year, desiredDate.Month, 1);
            var lastDayOfMonth = new DateTime(desiredDate.Year, desiredDate.Month + 1, 1); // + 1 to fix issue with API response that doesn't include last day of month

            tasks.Add(ApiService.GetMonthlyData(firstDayOfMonth.ToString("yyyy-MM-dd"), lastDayOfMonth.ToString("yyyy-MM-dd"), Latitude, Longitude));

            // Loop for going back year by year
            for (var i = 1; i <= 20; i++)
            {
                var yearToSubtract = desiredDate.Year - i;
                var firstDayOfYear = new DateTime(yearToSubtract, desiredDate.Month, 1);
                var lastDayOfYear = new DateTime(yearToSubtract, desiredDate.Month + 1, 1);
                tasks.Add(ApiService.GetMonthlyData(firstDayOfYear.ToString("yyyy-MM-dd"), lastDayOfYear.ToString("yyyy-MM-dd"), Latitude, Longitude));
            }
        }
        else
        {
            for (var i = 0; i < 20; i++)
            {
                var dateString = desiredDate.AddYears(-i).ToString("yyyy-MM-dd");
                tasks.Add(ApiService.GetHistoricalWeatherData(dateString, Latitude, Longitude));
            }
        }

        return await Task.WhenAll(tasks);
    }


    private static MultipleWeatherResponseModel MergeWeatherResponses(IEnumerable<MultipleWeatherResponseModel?> responses, int day)
    {
        var mergedResponse = new MultipleWeatherResponseModel();

        var weatherList = responses
            .Where(response => response?.weather != null)
            .SelectMany(response => response?.weather)
            .Where(weather => weather?.TimeStamp.Day == day)
            .GroupBy(weather => weather?.TimeStamp)
            .Select(group => group.First())
            .ToList();

        mergedResponse.weather = weatherList.ToArray();

        return mergedResponse;
    }

    private void DisplayDailyMeans(IReadOnlyCollection<DayModel> days)
    {
        CalculateDailyMeans(days);
        FindRecordHighAndLow(days);
    }

    private void CalculateDailyMeans(IReadOnlyCollection<DayModel> days)
    {
        MeanTemp = CalculateAverage(days, x => x.MeanTemp);
        MaxTemp = CalculateAverage(days, x => x.MaxTemp);
        MinTemp = CalculateAverage(days, x => x.MinTemp);
        Precipitation = CalculateAverage(days, x => x.Precipitation);
        SunshineHours = CalculateAverage(days, x => x.SunshineHours);
    }

    private static double CalculateAverage<T>(IEnumerable<T> collection, Func<T, double> selector)
    {
        return collection.Average(selector);
    }

    private void FindRecordHighAndLow(IReadOnlyCollection<DayModel> days)
    {
        var recordHighData = days.MaxBy(x => x.MaxTemp);
        var recordLowData = days.MinBy(x => x.MinTemp);

        if (recordHighData != null)
        {
            RecordHigh = recordHighData.MaxTemp;
            RecordHighYear = recordHighData.Year;
        }

        if (recordHighData == null || recordLowData == null) return;

        RecordLow = recordLowData.MinTemp;
        RecordLowYear = recordLowData.Year;
    }


    private void AssignValues()
    {
        if (CurrentWeather?.sources != null) StationName = CurrentWeather?.sources[0].StationName;
        Temperature = CurrentWeather?.weather?.Temperature;
        _humidity = CurrentWeather?.weather?.Humidity;
        DewPoint = CurrentWeather?.weather?.DewPoint;
        CloudCover = CurrentWeather?.weather?.CloudCover;
        
        SetWeatherLogo();
    }

    private void SetWeatherLogo()
    {
        Icon = CurrentWeather?.weather?.Icon switch
        {
            "clear-day" => "sunny",
            "cloudy" => "cloudy",
            "rainy" => "rainy",
            "partly-cloudy-day" => "partly-cloudy",
            "thunderstorm" => "thunderstorm",
            "clear-night" => "clear-night",
            "partly-cloudy-night" => "cloudy-night",
            _ => Icon
        };
    }
    #endregion
}
